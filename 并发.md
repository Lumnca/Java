# —————————————并发———————————— #

<p id="t"></p>

## :book:并发 ##

:arrow_double_down:<a href="#a1">线程</a>

:arrow_double_down:<a href="#a2">中断线程</a>

<p id="a1"><p>
  
### :crossed_flags:线程 ###

:arrow_double_up:<a href="#t">返回目录</a>

通常，一个任务称为一个线程，它是线程控制的简称。可以同时运行一个以上线程的程序称为多线程程序。

那么多进程与多线程的区别在哪里呢？本质的区别在于每个进程拥有自己的一整套变量，而线程是共享数据。更多信息参考[线程](https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101?fr=aladdin)

为了模拟这个问题，我们先看以下代码：

```java
    public  static void main(String arg[])throws IOException
    {
        Download("VS编译器");
        Download("LOL压缩包");
    }
    static void Download(String text){
        int i = 0;
        int w = 10;
        System.out.println("开始下载文件:"+text);

        while(true){
            try{
                Thread.sleep(1000);          //延时代码，需要抛出异常
                i++;
                System.out.println(text+"下载进度:"+i*100/w+"%");
            }
            catch (Exception e){
                e.printStackTrace();
                System.out.println(text+"下载异常!");
            }
            if(i==10){
                break;
            }
        }
        System.out.println(text+"下载完毕。");
    }
```

运行代码，可以看到我们必须按照顺序执行两个下载文件，但是在平时生活中，我们的下载是可以一起下载的。由于我们的代码是按照顺序执行的，所以不会同时进行这两个方法，但是多线程可以让我们同时执行这两个方法，让他们单独运行，不影响其他的进程。最简单的是使用Runable接口创建一个任务，再使用Thread由Runable得得到的任务创建一个线程， 。这个接口非常简单，只有一个方法：

```java
public interface Runnable
{
    void run();
}
```

由于Runnable是一个函数式接口，可以用lambda表达式建立一个实例，再使用Thread创建线程：


```java
    public  static void main(String arg[])throws IOException
    {
        Runnable r1 = ()->{
            Download("VS编译器");
        };
        Runnable r2 = ()->{
            Download("LOL压缩包");
        };
        Thread t1 = new Thread(r1);
        Thread t2 = new Thread(r2);

        t1.start();   //线程启动
        t2.start();   //线程启动
    }
    static void Download(String text){
        int i = 0;
        int w = 10;
        System.out.println("开始下载文件:"+text);

        while(true){

            try{
                Thread.sleep(1000);
                i++;
                System.out.println(text+"下载进度:"+i*100/w+"%");
            }
            catch (Exception e){
                e.printStackTrace();
                System.out.println(text+"下载异常!");
            }
            if(i==10){
                break;
            }
        }
        System.out.println(text+"下载完毕。");
    }
 ```

再次运行就可以看到两个方法是同时运行的。

Thread类：

```java
Thread(Runnable target)  : 构造一个新线程，

void start() :   启动这个线程，将引发调用run()方法。这个方法将立即返回，并且新线程将并发运行。

void run()   :  调用关联Runnable的run的方法。

sleep(long i) : i毫秒的延时 
```
Runnable类：

```java
void run() ： 必须覆盖这个方法，并在这个方法中提供所要执行的任务指令。
```

<p id="a2"><p>
  
### :crossed_flags:中断线程 ###

:arrow_double_up:<a href="#t">返回目录</a>

当线程的run方法执行方法体中最后一条语句后，并经由执行return语句返回时，或者出现了在方法中没有捕获的异常时，线程将终止。在java早期有一个stop的方法用于终止线程，但现在已经被废弃了。没有可以强制停止线程的方法，然而，`interrupt`方法可以用来请求终止线程。线程的中断状态将被置位，这是由于每个线程都有的boolean标志，每个线程都应该不时的检查这个标志，以判断线程是否被中断。要想弄清中断状态是否被置位，首先调用静态的`Thread.currentThread`方法获得当前线程，然后调用`isInterrupted`方法：

```java
    public  static void main(String arg[])throws IOException
    {
        Runnable r1 = ()->{

                Download("VS编译器");
                while (!Thread.currentThread().isInterrupted())
                {
                    System.out.println("下载已终止");
                    break;
                }
        };
        Scanner in = new Scanner(System.in);
        Thread t1 = new Thread(r1);
        t1.start();
        String option =  in.next();
        if("s".equals(option)){
            t1.interrupt();
        }
    }
    static void Download(String text){
        int i = 0;
        int w = 10;
        System.out.println("开始下载文件:"+text);

        while(true){

            try{
                Thread.sleep(1000);
                i++;
                System.out.println(text+"下载进度:"+i*100/w+"%");
            }
            catch (Exception e){
                e.printStackTrace();
                System.out.println(text+"下载异常!");
                break;
            }
            if(i==10){
                System.out.println(text+"下载完毕。");
                break;
            }
        }
    }
```

可以看到线程停止，但是抛出InterruptedException异常继续运行，当在一个被阻塞的线程（调用了sleep或wait）调用interrupt方法时，阻塞调用将会被
InterruptedException异常中断，如上我们的代码，这是由于存在不能被中断的阻塞I/O调用，应该考虑选择可中断的调用。没有任何语言需要要求一个被中断的线程应该终止，中断一个线程不过是引起它的注意，被中断的线程可以决定如响应中断，某些线程是处理完异常后，继续执行，而不理会中断。更多的是线程将简单地中断作为一个终止的请求。使用不含有延时的函数就不会抛出异常，实际运用中下载是用不到延时的，上面只是模仿这个过程，如下我们可以中断：

```java
    public  static void main(String arg[])throws IOException
    {
        Runnable r1 = ()->{
            while (!Thread.currentThread().isInterrupted())
            {
                System.out.println("线程正在执行中");
                //模拟下载
            }
        };
        Thread t1 = new Thread(r1);
        t1.start();

        try {
            Thread.sleep(3000);
            t1.interrupt();
        }
        catch (Exception e){
            e.printStackTrace();
        }
    }
```

thread类：

```java
void interrupt() : 向线程发送中断请求，线程的中断状态将被设置为true，如果线程被一个sleep调用阻塞，那么会抛出InterruptedException异常

static boolean interrupted() :测试当前线程是否被中断，这是个静态方法，这一调用会产生副作用---它将当前线程中断重置为false。

boolean isInterrupted() ： 测试线程是否终止，这个不改变线程状态。

static ThreadcurrentThread() : 返回代表当前执行线程的Thread对象。
```



















