# —————————————并发———————————— #

<p id="t"></p>

## :book:并发 ##

:arrow_double_down:<a href="#a1">线程</a>

:arrow_double_down:<a href="#a2">中断线程</a>

<p id="a1"><p>
  
### :crossed_flags:线程 ###

:arrow_double_up:<a href="#t">返回目录</a>

通常，一个任务称为一个线程，它是线程控制的简称。可以同时运行一个以上线程的程序称为多线程程序。

那么多进程与多线程的区别在哪里呢？本质的区别在于每个进程拥有自己的一整套变量，而线程是共享数据。更多信息参考[线程](https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101?fr=aladdin)

为了模拟这个问题，我们先看以下代码：

```java
    public  static void main(String arg[])throws IOException
    {
        Download("VS编译器");
        Download("LOL压缩包");
    }
    static void Download(String text){
        int i = 0;
        int w = 10;
        System.out.println("开始下载文件:"+text);

        while(true){
            try{
                Thread.sleep(1000);          //延时代码，需要抛出异常
                i++;
                System.out.println(text+"下载进度:"+i*100/w+"%");
            }
            catch (Exception e){
                e.printStackTrace();
                System.out.println(text+"下载异常!");
            }
            if(i==10){
                break;
            }
        }
        System.out.println(text+"下载完毕。");
    }
```

运行代码，可以看到我们必须按照顺序执行两个下载文件，但是在平时生活中，我们的下载是可以一起下载的。由于我们的代码是按照顺序执行的，所以不会同时进行这两个方法，但是多线程可以让我们同时执行这两个方法，让他们单独运行，不影响其他的进程。最简单的是使用Runable接口创建一个任务，再使用Thread由Runable得得到的任务创建一个线程， 。这个接口非常简单，只有一个方法：

```java
public interface Runnable
{
    void run();
}
```

由于Runnable是一个函数式接口，可以用lambda表达式建立一个实例，再使用Thread创建线程：


```java
    public  static void main(String arg[])throws IOException
    {
        Runnable r1 = ()->{
            Download("VS编译器");
        };
        Runnable r2 = ()->{
            Download("LOL压缩包");
        };
        Thread t1 = new Thread(r1);
        Thread t2 = new Thread(r2);

        t1.start();   //线程启动
        t2.start();   //线程启动
    }
    static void Download(String text){
        int i = 0;
        int w = 10;
        System.out.println("开始下载文件:"+text);

        while(true){

            try{
                Thread.sleep(1000);
                i++;
                System.out.println(text+"下载进度:"+i*100/w+"%");
            }
            catch (Exception e){
                e.printStackTrace();
                System.out.println(text+"下载异常!");
            }
            if(i==10){
                break;
            }
        }
        System.out.println(text+"下载完毕。");
    }
 ```

再次运行就可以看到两个方法是同时运行的。

Thread类：

```java
Thread(Runnable target)  : 构造一个新线程，

void start() :   启动这个线程，将引发调用run()方法。这个方法将立即返回，并且新线程将并发运行。

void run()   :  调用关联Runnable的run的方法。

sleep(long i) : i毫秒的延时 
```
Runnable类：

```java
void run() ： 必须覆盖这个方法，并在这个方法中提供所要执行的任务指令。
```

<p id="a2"><p>
  
### :crossed_flags:中断线程 ###

:arrow_double_up:<a href="#t">返回目录</a>

当线程的run方法执行方法体中最后一条语句后，并经由执行return语句返回时，或者出现了在方法中没有捕获的异常时，线程将终止。
























