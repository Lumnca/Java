# —————————————集合———————————— #

<p id="t"></p>

## :book:集合 ##

:arrow_double_down:<a href="#a1">Java集合框架</a>

:arrow_double_down:<a href="#a2">具体的集合</a>

<p id="a1"><p>
  
### :crossed_flags:Java集合框架 ###

:arrow_double_up:<a href="#t">返回目录</a>

#### :hatched_chick:将集合的接口与现实分离 ####

与现代的数据结构一样，Java集合类库也将接口与现实分离，首先看下我们所熟悉的数据结构--队列是如何分离的。有关队列我们就不多阐述，直接看下队列的接口：

```java
    public  interface  Queue<E>
    {
        void add(E element);
        E remove();
        int size();
    }
```

其中add方法为向队列添加元素，remove是删除一个元素。size是队列大小。当然这只是个接口定义，真正的队列直接使用LinkedList类，这个类实现了Queue接口。上面的这个接口并没有说明队列是怎么实现的，队列通常有两种实现方式：一种是使用循环数组，二是使用链表。当然这两种形式需要自己去定义。

关于这两种方式需要自己去实现这个接口，接口本身并不能说明那种实现方式究竟如何，循环数组比链表更高效，因此多数人优先选择循环数组。然而，通常这样做也有代价。循环数组是一个有界集合，即容量有限，如果程序中要收集的对象没上上限，那么最好使用链表。

#### :hatched_chick:Collection接口 ####

在java类库中，集合类的基本接口是Collection接口，这个接口有两个基本的方法：

```java
    public  interface  Collection<E>{
        boolean add(E element);
        Iterator<E> iterator();
    }
```

其余方法后面介绍，add方法用于添加元素，如果添加成功返回true。反之亦然。iterator方法用于返回一个实现了Iteratior接口的对象，可以使用这个迭代器对象依次访问集合中的元素。


#### :hatched_chick:迭代器 ####

iterator接口包含4个方法

```java
    public  interface  iterator<E>{
            E next();
            boolean hasNext();
            void remove();
            default  void forEachRemaining(Consumer<? super  E> action);
    }
```

通过反复调用next()方法，可以逐步访问集合中的每个元素。但是，如果达到了集合的末尾，就会抛出一个异常。如果想看集合中的每个元素，就需要请求一个迭代器，并在hasNext返回true时反复地调用next方法。例如

```java
      Collection<String> coll = ...;
      Iterator<String>  iterator = coll.iterator();
      
       while (iterator.hasNext())
       {
          String element = iterator.next();
       }
```

用foreach循环也可以实现同样的操作：

```java
      Collection<String> coll = ...;
      for(String element : coll){
          System.out.println(element);
      }
```

在Java SE8中，甚至不用写循环，可以调用forEachRemaining方法并提供一个lambda表达式（处理元素）。将对迭代器的每个元素调用这个lambda表达式，直到再没有元素为止。


```java
     Collection<String> coll = ...;
     Iterator<String>  iterator = coll.iterator();
     iterator.forEachRemaining(element -> System.out.println(element));
```

方然关于迭代顺序，取决于集合类型，如果对ArrayList进行迭代，迭代器将从索引0开始，后面索引值依次加一，然而，如果访问HashSet中的元素，每个元素将会某种随机的次序出现。

注意一个点就是这个有点类似数据结构的链表，当你要删除某个节点时，你需要把链表指针指到该节点的前，next方法就会让链表节点往后移一位。比如删除第二个节点：


```java
     Collection<String> coll = ...;
     Iterator<String>  iterator = coll.iterator();
     iterator.next();       //移动下一位
     iterator.remove();     //移除该元素
```

所以next与remove方法的调用具有依赖性。如果调用remove之前没有调用next方法是不合法的，这样会抛出一个异常。如果想删除相邻的两个元素不能像下面这样做：

```java
  iterator.remove();
  iterator.remove();
```

相反的需要调用next越过将要删除的元素：

```java
    iterator.remove();
    iterator.next();
    iterator.remove();
```

也就是说移除某个元素后后面的节点并没有依次补上，还是需要手动将位置移到下一位。

#### :hatched_chick:泛型实用方法 ####

由于Collection与Iterator都是泛型接口，可以编写操作任何集合类型的实用方法。这两个接口声明了很多有用的方法，所有的实现类都必须提供这些方法，下面是这些的方法的介绍：


```java
 @Override
               public int size() {
                   return 0;
               }

               @Override
               public boolean isEmpty() {
                   return false;
               }

               @Override
               public boolean contains(Object o) {
                   return false;
               }

               @Override
               public Iterator<String> iterator() {
                   return null;
               }

               @Override
               public Object[] toArray() {
                   return new Object[0];
               }

               @Override
               public <T> T[] toArray(T[] a) {
                   return null;
               }

               @Override
               public boolean add(String s) {
                   return false;
               }

               @Override
               public boolean remove(Object o) {
                   return false;
               }

               @Override
               public boolean containsAll(Collection<?> c) {
                   return false;
               }

               @Override
               public boolean addAll(Collection<? extends String> c) {
                   return false;
               }

               @Override
               public boolean removeAll(Collection<?> c) {
                   return false;
               }

               @Override
               public boolean retainAll(Collection<?> c) {
                   return false;
               }

               @Override
               public void clear() {

               }
 ```












